---
layout:     post
title:      Nodejs实战
subtitle:   chapter03：Node 编程基础
date:       2023-09-10
author:     forwardZ
header-img: img/the-first.png
catalog: false
tags:
    - 服务端_Nodejs_数据库
---



## Chapter03：Node 编程基础

目标：

1. 如何组织代码？-回调 & 事件发射器
2. 如何异步编程？-流程控制，串行 & 并行

经验丰富的程序员，

1. 按照概念将逻辑组织成类和函数；
2. 将包含类和函数的文件组织到源码树的目录中；
3. 最后代码被组织到程序和库中；

将学习到：

1. 如何响应一次性事件；
2. 如何处理重复性事件；
3. 如何让异步逻辑顺序执行；

模块是Node让代码易于重用的一种组织和包装方式。

### 一，Node 功能的组织及重用

用目录和单独的文件组织起来的代码找起来要比整个程序代码都放在一个 长文件中找起来更容易。

Node模块打包代码是为了重用，但它们不会改变全局作用域。

Node模块允许你从被引入文件中选择要暴露给程序的函数和变量。如果模块返回的函数或变 量不止一个，那它可以通过设定exports对象的属性来指明它们。但如果模块只返回一个函数或变量，则可以设定module.exports属性。

Node的模块系统避免了对全局作用域的污染，从而也就避免了命名冲突，并简化了代码的重用。

#### 一）创建模块

使用这个新模块要用到Node的require函数，该函数以你要用的模块的路径为参数。Node 以同步的方式寻找它，定位到这个模块并加载文件中的内容。

require是Node中少数几个同步I/O操作之一。通常都只在程序最初加载时才使用require和其他同步操作。

组装模块中的exports对象是在单独的文件中组织可重用代码的一种简便方法。

#### 二）用module.exports微调模块的创建

Node觉得不能用任何其他对象、函数或变量给exports赋值，也即Node不允许 重写**exports**。最终在程序里导出的是module.exports。exports只是对module.exports的一个全 局引用，最初被定义为一个可以添加属性的空对象。所以exports.myFunc只是module.exports.myFunc的简写。如果把exports设定为别的，就打破了module.exports和exports之间的 引用关系。

用module.exports 可以对外提供单个变量、函数或者对象。如果你创建了一个既有exports又有module.exports 的模块，那它会返回module.exports，而exports会被忽略。

#### 三）用node_modules重用模块

要求模块在文件系统中使用相对路径存放，对于组织程序特定的代码很有帮助，但对于想要 在程序间共享或跟其他人共享代码却用处不大。Node中有一个独特的模块引入机制，可以不必知 道模块在文件系统中的具体位置。这个机制就是使用node_modules目录。

node_modules机制（TODO❗️❓）

用环境变量NODE_PATH可以改变Node模块的默认路径。如果用了它，NODE_PATH在Windows中应该设置为用分号分隔的目录列表，在其他操作系统中用冒号分隔。查找模块的步骤详细见图3-5。

#### 四）注意事项

第一，如果模块是目录，在模块目录中定义模块的文件必须被命名为index.js，除非你在这个 目录下一个叫package.json的文件里特别指明。

第二，Node能把模块作为对象缓存起来。如果程序中的两个文件引入了相 同的模块，第一个文件会把模块返回的数据存到程序的内存中，这样第二个文件就不用再去访问 和计算模块的源文件了。

猴子补丁（TODO❗️❓）

### 二，异步编程技术

在Node的世界里流行两种响应逻辑管理方式：回调和事件监听。

回调通常用来定义一次性响应的逻辑。

事件监听器，本质上也是一个回调，不同的是，它跟一个概念实体(事件)相关联。

学习内容：

1. 如何用回调处理一次性事件;
2. 如何用事件监听器响应重复性事件;
3. 异步编程的几个难点

#### 一）用回调处理一次性事件

回调是一个函数，它被当做参数传给异步函数，它描述了异步操作完成之后要做什么。

#### 二）用事件发射器处理重复性事件

事件发射器会触发事件，并且在那些事件被触发时能处理它们。一些重要的Node API组件，如HTTP服务、TCP服务和流，都被做成了事件发射器。

事件是通过监听器处理的，监听器是和事件相关联的，带有一个事件出现时就会被触发的回调函数。

下面的内容待实践（TODO❗️❓）

##### 1，事件发射器示例

##### 2，响应只应该发生一次的事件

##### 3，创建事件发射器

##### 4，拓展事件监听器：文件监视器

#### 三）异步开发的难题

创建异步程序时，必须密切关注程序的执行流程，及程序的状态：事件轮询的条件、程序变量，以及其他随着程序逻辑执行而发生变化的资源。

闭包结合匿名函数保留全局变量的值

```js
function asyncFunction(callback) {
  setTimeout(function() {
    callback() // blue
  }, 200);
}
var color = 'blue';
(function(color) {
  asyncFunction(function() {
    console.log('The color is ' + color);
  })
})(color);
color = 'green';
```

### 三，异步逻辑的顺序化

让一组异步任务顺序执行的概念被Node社区称为流程控制。这种控制分为两类:串行和并行，需要一个接着一个做的任务叫做串行任务，不需要一个接着一个做的任务叫做并行任务。

跟踪串行和并行的流程控制要做编程记账的工作，在实现串行化流程控制时，需要跟踪当前 执行的任务，或维护一个尚未执行任务的队列。实现并行化流程控制时需要跟踪有多少个任务要执行完成了。

先从何时以及如何在异步的世界中实现串行化流程控制开始。

#### 一）什么时候使用串行流程控制

可以使用回调让几个异步任务按顺序执行，注意组织代码，防止嵌套过多带来的可读性差。

#### 二）实现串行化流程控制

为了用串行化流程控制让几个异步任务按顺序执行，需要先把这些任务按预期的执行顺序放 到一个数组中。这个数组将起到队列的作用:完成一个任务后按顺序从数组中取 出下一个。数组中的每个任务都是一个函数。任务完成后应该调用一个处理器函数，告诉它错误状态和 结果。如果有错误，处理器函数会终止执行;如果没有错误，处理器就从队列中取出下一个任务 执行它。

串行化流程控制本质上是在需要时让回调进场，而不是简单地把它们 嵌套起来。

关键代码：

```js
function downloadRSSFeed(feedUrl) {
  request({ uri: feedUrl }, function (err, res, body) {
    if (err) return next(err);
    if (res.statusCode != 200)
      return next(new Error('Abnormal response status code'))

    next(null, body);
  });
}

var tasks = [checkForRSSFile,
  readRSSFile,
  downloadRSSFeed,
  parseRSSFeed];

function next(err, result) {
  if (err) throw err;
  var currentTask = tasks.shift();
  if (currentTask) {
    currentTask(result);
  }
}
```

#### 三）实现并行化流程控制

为了让异步任务并行执行，仍然是要把任务放到数组中，但任务的存放顺序无关紧要。每个任务都应该调用处理器函数增加已完成任务的计数值。当所有任务都完成后，处理器函数应该执行后续的逻辑。

#### 四）利用社区的工具

社区中的很多附加模块都提供了方便好用的流程控制工具。其中比较流行的有Nimble、Step和Seq三个。（PS：好像年代都比较久远）

### 四，小结

1. Node的模块系统基于CommonJS模块规范，可以通过组装exports和module.exports轻松重用模块；
2. 可以用回调、事件发射器和流程控制管理异步逻辑；
3. 事件发射器对组织异步逻辑很有帮助，因为它们可以把异步逻辑跟 一个概念实体关联起来，可以通过监听器轻松管理；

























